/**
 * Zig Wrapper 生成模块
 *
 * 生成用于 Linux 交叉编译的 Zig wrapper 脚本
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { getZigTarget } from './types';

/**
 * Zig wrapper 脚本模板
 */
const ZIG_WRAPPER_TEMPLATE = `#!/bin/bash
# Zig wrapper script for .NET Native AOT cross-compilation
# Generated by vscode-dotnet-deploy
# This script filters out incompatible linker arguments for Zig

# Default target (can be overridden by detecting RID from args)
TARGET="{{TARGET}}"

# Detect target architecture from arguments
for arg in "$@"; do
  case "$arg" in
    *aarch64-linux-gnu*)
      TARGET="aarch64-linux-gnu"
      break
      ;;
    *x86_64-linux-gnu*)
      TARGET="x86_64-linux-gnu"
      break
      ;;
    *aarch64-linux-musl*)
      TARGET="aarch64-linux-musl"
      break
      ;;
    *x86_64-linux-musl*)
      TARGET="x86_64-linux-musl"
      break
      ;;
  esac
done

# Build filtered argument array
# Skip arguments that are incompatible with Zig's linker
args=()
for arg in "$@"; do
  case "$arg" in
    # Skip incompatible arguments
    -pie|-fuse-ld=bfd|-gz=zlib|-Wl,-pie|-Wl,--gc-sections|-Wl,-z,nostart-stop-gc)
      ;;
    # Skip empty arguments
    "")
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Call zig cc with target and filtered arguments
exec zig cc -target "$TARGET" "\${args[@]}"
`;

/**
 * 获取临时目录中的 wrapper 路径
 */
function getWrapperDir(): string {
    return path.join(os.tmpdir(), 'dotnet-deploy-crosscompile');
}

/**
 * 生成 Zig wrapper 脚本
 *
 * @param runtime 目标运行时 (如 linux-x64)
 * @returns wrapper 脚本的绝对路径
 */
export function generateZigWrapper(runtime: string): string {
    const wrapperDir = getWrapperDir();
    const wrapperPath = path.join(wrapperDir, 'zig-wrapper');

    // 确保目录存在
    fs.mkdirSync(wrapperDir, { recursive: true });

    // 获取 Zig 目标三元组
    const target = getZigTarget(runtime);

    // 生成脚本内容
    const script = ZIG_WRAPPER_TEMPLATE.replace('{{TARGET}}', target);

    // 写入脚本
    fs.writeFileSync(wrapperPath, script, { mode: 0o755 });

    return wrapperPath;
}

/**
 * 检查 wrapper 是否已存在且有效
 */
export function isWrapperValid(runtime: string): boolean {
    const wrapperPath = path.join(getWrapperDir(), 'zig-wrapper');

    if (!fs.existsSync(wrapperPath)) {
        return false;
    }

    try {
        const content = fs.readFileSync(wrapperPath, 'utf-8');
        const target = getZigTarget(runtime);
        return content.includes(`TARGET="${target}"`);
    } catch {
        return false;
    }
}

/**
 * 获取 wrapper 路径 (如果不存在则创建)
 */
export function getOrCreateZigWrapper(runtime: string): string {
    if (!isWrapperValid(runtime)) {
        return generateZigWrapper(runtime);
    }
    return path.join(getWrapperDir(), 'zig-wrapper');
}

/**
 * 清理临时 wrapper 文件
 */
export function cleanupZigWrapper(): void {
    const wrapperDir = getWrapperDir();

    try {
        if (fs.existsSync(wrapperDir)) {
            fs.rmSync(wrapperDir, { recursive: true, force: true });
        }
    } catch {
        // 忽略清理错误
    }
}

/**
 * 获取 Linux 交叉编译所需的 MSBuild 参数
 */
export function getLinuxCrossCompileArgs(runtime: string, stripSymbols: boolean): string[] {
    const wrapperPath = getOrCreateZigWrapper(runtime);

    const args: string[] = [
        `-p:CppCompilerAndLinker=${wrapperPath}`,
        '-p:DisableUnsupportedError=true',
    ];

    // 默认禁用符号剥离 (除非用户明确启用且安装了 llvm-objcopy)
    if (!stripSymbols) {
        args.push('-p:StripSymbols=false');
    }

    return args;
}

/**
 * 获取 musl 目标的额外提示
 */
export function getMuslNote(runtime: string): string | null {
    if (runtime.includes('musl')) {
        return 'musl 目标用于 Alpine Linux 等轻量级发行版，生成的二进制文件不依赖 glibc。';
    }
    return null;
}
